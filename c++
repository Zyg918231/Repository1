1、c++三大特性
  封装、继承、多态
  
2、重载、重写、隐藏的区别
  重载：在一个作用域内，函数名称相同、参数列表不同，返回值可相同可不同，构成重载
  重写：在基类和子类之间，函数名称相同且参数列表相同，基类函数有virtual关键字，构成重写
  隐藏：在基类和子类之间，函数名称相同，构成覆盖
  协变：是重写的一种特殊情况，返回类型不一致

3、c++静态多态和动态多态
  动态多态：是运行时的多态，是通过父类和子类的继承关系和虚函数的使用来实现的，基类指针指向父类对象，调用父类的方法，指向子类对象，调用子类的方法
  静态多态：通过函数重载和模板来实现的，概念一起根据参数类型进行静态绑定，决定使用哪个函数
  
4、final关键字作用
  放在类后表示该类无法被继承，放在虚函数后，阻止虚函数的重载
  
5、虚函数的实现原理
虚函数表：每个包含虚函数的类都有一个u虚函数表，寻出该类的所有虚函数地址，
虚函数指针：在对象的内存布局中，编译器会添加一个额外的指针，成为虚函数指针或虚表指针，该指针指向对象对应的虚函数表
  
6、匿名函数
匿名函数本质是一个对象，在定义过程中会创建出一个栈对象，内部通过重载（）符合实现函数调用
优点：匿名函数，免去函数的声明和定义，在调用时创建函数对象，结束时里脊释放，节省空间
  
7、右值引用
为一个临时变量起别名，绑定在一个临时变量或变大时上
移动语义： 右值在生命周期结束后会被销毁，通过右值引用可以避免重复复制的操作，将资源所有权从一个对象转移到另一个对象，实现移动语义
完美转发：无论传进的是左值还是右值，通过右值引用将传进的参数以原始的类型传出，避免不必要的拷贝或移动操作
  
8、指针和引用区别
指针可以不用初始化，引用必须初始化
指针是一个变量，引用是一个别名
指针有自己的空间地址，引用和引用对象占了同一个空间
  
9、#define 和 const区别
  define是编译预处理阶段进行简单的文本替换，const在编译阶段确定其值
  define定义的宏常量没有数据类型，不会进行安全检查，const会进行类型判断

10、锁的底层原理
CAS和atomic机制，CAS将操作转换成原子操作，原子操作不会被调度机制打断的操作，

11、 class和struct的区别
class中的成员默认为私有(private)，struct默认访问权限是public
class支持继承，struct不支持
class自动申城默认的构造函数，struct不会自动生成

12、在main函数之前，都做了什么操作
  设置堆栈指针
  初始化全局静态变量和global全局变量
  全局对象和全局变量初始化
  传入argc、argv参数

13、堆栈的区别
  栈（Stack）:由编译器自动分配和释放，存放函数的参数，局部变量、临时变量、函数返回地址等。
  堆（Heap）:由程序员分配和释放，对于C/C++必须要手动释放开辟的堆空间，否则会引起内存泄漏。
  堆分配速度慢，容易产生内存碎片，向高地址扩展
  栈向低地址扩展
  
14、构造函数和析构函数
  构造函数不能为虚函数，析构函数经常为虚函数，否则只会调用父类的析构函数，造成内存泄露
  先构造父类的构造函数，再构造子类的构造函数，先析构子类的析构函数，再析构父类的析构函数

15、静态变量再哪里初始化
  静态变量、全局变量、常量都在编译阶段完成初始化和内存分配，局部变量运行时完成初始化和内存分配
  
16、Move底层实现
  Move功能是将左值引用转换成右值引用，实现原理是强制类型转换
优点：可以将左值变成右值，避免拷贝构造

17、空类有什么函数
默认构造函数、默认拷贝构造函数、默认析构函数

18、explicit有什么用？
只能用来修饰只有一个参数的构造函数，除非除了第一个参数，其它参数都有默认值，标明该构造函数时显示的，非隐式的，防止类构造函数的隐式自动转换

19、成员变量的初始化顺序
基类的静态和全局变量、派生类的静态和全局、父类的成员变量、子类的成员变量
顺序和变量的定义顺序有关、和初始化列表无关

20、野指针和内存泄漏
野指针：指向一个已经删除的对象或未申请访问受限内存区域的指针
避免：指针初始化、指针释放完内存后，将指针赋值为nullpter
内存泄漏：程序以动态分配的堆内存由于某种原因程序未释放或无法释放

21、malloc和new
  malloc分配失败后返回空，new抛出异常
  new、delete会调用析构函数，malloc、free不会调用

22、map和unordered_map的区别
map内部是红黑树、内部所有元素是有序的，hashmap内部是哈希表，无序的
unordered_map内存占用高，效率高
map效率低，但有序

23、vector的push_back和emplace_back
emplace_back在vector末尾直接构造对象，比push_back少了一次构造函数调用
vector的resize改变vector的大小，reserve是配置capacity的大小

24、虚基类
  用于结局菱形继承的问题，一个派生类继承两个基类，两个基类又共同继承同一个虚基类，
  
25、动态链接库和静态链接库
  区别：静态链接时在编入可行性程序，动态链接是在软件执行时
  静态库：将库中代码包含到程序中，占空间打
  动态库：不会直接复制到自己程序内，只会留下接口，运行时加载到内存

26、b未初始化全局变量放在bss段，初始化的全局变量放在data段  

27、强制类型转换有哪几种类型
  static_cast：数据类型的强制转换，基本类型，基类派生类转换
  const_cast: const和非const直接转换
  Reinterpret_cast:用于改变指针和引用的类型
  Dynamic_cast:运行时进行类型转换，在类层次间进行转换

28、make_shared函数优点
优点：减少内存分配次数，降低系统开销，
缺点：构造函数为保护或私有无法使用make_shared函数
会调职weak_ptr保持控制块到整个生命周期




















